/** Generators system
 *
 * Generators is possibly unbound stream of values,
 * generated by using some state, or by some independed flow
 * of execution (in example loop). Generators of Fiber type
 * are similar to threads and functions, that they
 * can look like being executed in parallel, and can "return"
 * multple times from function. Fibers are also usefull
 * to implmenet complex behvaiours of iterations like recursion.
 *
 * Generators are usefull for implementing iterators,
 * Visitor pattern, and analyzing time series data in dynamic fashion.
 *
 * Examples of unbound Generator can be random number generator,
 * or event from the external source (like network), or clock ticks.
 *
 * What differs Generators from Threads+message passing,
 * is that Fibers executes in the same process/thread context
 * as caller, and are executed synchronously. (caller will
 * wait until requested value is computed). They are also
 * scheduled cooperativly (caller is waiting until
 * calee ends and indicate this explicitly).
 *
 * This in some situations can make Generator much more
 * efficient than Threads. Being comparable to plain for loop
 * over aggregate.
 *
 * They are very usefull in abstracting sequence of items,
 * in datastructures or infinite lists which are computed in lazy manner.
 *
 * What is problematic in any kind of Generators is
 * that it is practically not possible to
 * inline foreach body with generator code,
 * so in most cases Generators are slightly slower,
 * than tuned and inlined for loops.
 *
 * This is because, in normal for loop with calls to other funciton f,g
 * this functions f and g are called, and possibly inlined.
 *
 * In Generators situation is different, f and g stay in place, but the "for"
 * construct is our function, and f and g are passed as parameters.
 * No known compiler inlines f/g passed as value/reference to existing function,
 * this can be only fully achived by template techniques, or JIT compiler.
 *
 *
 * License: BSD
 * Author: Witold Baryluk <baryluk@smp.if.uj.edu.pl>
 * Copyright: Witold Baryluk, 2009
 */
module corod;

import core.thread : Fiber;

debug import std.stdio : writefln, writeln;

/** General generator exception */
class GeneratorException : Exception {
	UntypedGenerator who; /// reference to original generator which thrown it

	/// creats exception
	this(UntypedGenerator me, string mymsg = "generator general exception") {
		who = me;
		super(mymsg);
	}
}

/** Generator exception indicating End of values,
 * because iter() function ended by return or next() is not valid
 */
final class GeneratorEndException : GeneratorException {
	this(UntypedGenerator me, string mymsg = "end of generator") {
		super(me, mymsg);
	}
}

/** Just base for typed interface */
interface UntypedGenerator {
}

/** Main interface for Generators. All generators should implement this interface. */
interface Generator(T) : UntypedGenerator {
public:
	/// Get currentl value of generator
	T get();
	/// Progress generator by one item, returns false if there is no more items
	bool next();
	/// Combined get() and next() in one function, throws GeneratorEndException if end of items
	T getNext();
	/** Iterate over generator.
	 *
	 * implemention should respect break/continue behaviour, catch GeneratorException
	 * of underling used generators, and return correct value.
	 *
	 * Semantically it should be equivalent to
	 * ---
	 * try {
	 *   while(true) {
	 *     auto r = dg(this.getNext());
	 *     if (r) return r;
	 *   }
	 * } catch (...) ...
	 * ---
	 *
	 * For conviniance this general loop can be mixin-ed by template OpApplyMixin!(T).
	 */
	int opApply(int delegate(ref T));
}


/** Implementation of general opApply loop, using getNext, and exceptions
 *
 * Useage:
 *
 * class XX : Generator!(float) {
 *    bool next() { ... }
 *    float get() { ... }
 *    float getNext() { ... }
 *    mixin OpApplyMixin!(float) opApply;
 * }
 *
 */
template OpApplyMixin(T) {
	int opApply(int delegate(ref T) dg) {
		try {
			while(true) {
				auto v = this.getNext();
				auto r = dg(v);
				if (r) return r;
			}
		} catch (GeneratorEndException ge) {
			if (ge.who is this) {
				debug(exceptions) writefln("Generator G end exception: %s", ge.msg);
			} else {
				debug(exceptions) writefln("Generator ?? end exception: %s", ge.msg);
				throw ge;
			}
			return 0;
		} catch (GeneratorException ge) {
			debug(exceptions) writefln("Generator exception: %s", ge.msg);
			if (ge.who !is  this) {
				throw ge;
			}
			return 1;
		}

		return 0;
	}
}


//version = fiber_composed; // FiberGenerator having Fiber inside as field
version = fiber_derived; // FiberGenerator derivating from Fiber



version(fiber_composed) {
abstract class AFiberGenerator {
private:
	Fiber x;

protected:
	this(void delegate() dg) {
		x = new Fiber(dg);
	}

	~this() {
		debug(exceptions) writeln("dest AGenerator");
		delete x;
	}

	// reimplementation (forwarding) of relevant methods from Fiber
public:
	void call() {
		x.call();
	}
	void yield() {
		x.yield();
	}
	Fiber.State state() {
		return x.state;
	}
}
}

version(fiber_derived) {

/** Abstract class implementing generators as Fiber,
 * esentially all generators of all types implements this class.
 *
 * Info: Generators implemnted as Fibers are very flexible, and it
 * is easy to stack them, and also do complicated control-flow
 * inside of them. Also state of such Generators are implicitly
 * and automatically saved, so one can use an ykind of stack based
 * varaibles, including recursion.
 *
 * Remark: What is problematic, is that Fibers are quite costly when switching
 * beetwen Fibers, and beetwen main thread of execution, because
 * on modern CPUs stack segment register change incurse
 * big penalties, in branch misprediction, pipeline stall,
 * cache miss, and internal stack-cache miss.
 *
 * Note: If possible (when control flow is just while(true), or simple for/foreach
 * loop, use Generators which directly implements Generator!(T) interface,
 * in terms of next/get, and save relevant state in private
 * fields of class.
 *
 * Note: There is also provided BufferedFiberGenerator which uses buffering,
 *       to reduce context switches.
 *
 * Bug: Fiber are currently not garbage collected properly.
 * See: d.puremagic.com/issues/show_bug.cgi?id=3523
 * Use: Use GenWrap which is hack to make GC work with FiberGenerators
 * TODO: Fix bug #3523
 */
abstract class AFiberGenerator : Fiber {
protected:
	/** Start Fiber with delegate dg.
	 *
	 * This constructor is only used in FiberGenerator(T), and passes private run method, thish starts execution in protected iter method of the same object
	 */
	this(void delegate() dg) {
		super(dg);
	}
}
}


/** Abstract class template implementing generator of type T
 *
 * Simple testing generator, yielding 4 int values: 1, 5, 10, 14 in this order:
 * ---
 * final class Test : FiberGenerator!(int) {
 *    protected override void iter() {
 *       yield(1);
 *       yield(5);
 *       yield(10);
 *       yield(14);
 *    }
 * }
 * ---
 */
abstract class FiberGenerator(T) : AFiberGenerator, Generator!(T) {
protected:
	/** Starts Fiber with run method of this method. */
	this() {
		super(&run);
	}

public:
	/// take value last yielded
	final T get() {
		return value;
	}

	/** Return to the iter() function if generator have not ended execution yet.
	 *
	 * Returns imidietly if generator is not runing.
	 *
	 * iter() function will be executing up to the point of its termination,
	 * exception or yield method call.
	 *
	 * get() method can be used to take value passed to yield method
	 */
	final bool next() {
		if (state == Fiber.State.TERM) {
			return false;
		} else {
			this.call();
			return true;
		}
	}

	/** Same as next(), but returns yielded value,
	 * and throw GeneratorEndException if generator is not executing
	 */
	final T getNext() {
		if (next()) {
			return get();
		} else {
			throw new GeneratorEndException(this, "fibergenerator iteration ended");
		}
	}

//private:
public:
	T value; /// value saved by yield method

protected:
	/** Yields value x (saving it for retriving in method get()),
	 * giving back execution to next() function (which shall return true)
	 */

	final void yield(T x) {
		value = x;
		super.yield();
	}
/+
	 * TODO: Think about moving this method to auxilary class, which will
	 * have opCall overloaded (for simplicity) and will be passed to iter.
	 * This will allow easier implementation of recursive generators.
	 * Example: void iter(Yield!(T) yield) {  left.iter(yield);  yield(value); ritgh.iter(yield); }
	 * The small problem is with this is that for many fibergenerator, this additionall parameter will be cumberstome
	 * to write. Possible solution: compile time introspection of class, and addition of proper fields.
	 *
	 * Additionally independet Yield structure opens possibility of safer
	 * parallel iteration.
	 *
class Yield(T) {
	this(FiberGenerator!(T) f_) {
		f = f_;
	}
	private FiberGnerator!(T) f;
	void opCall(T x) {
		f.yield(x);
	}
}

or
template Yield(T) {
	alias delegate void(T) Yield;
}
Yield!(T) yield = delegate void(T x) { f.yield(x); };


It is already simple to write auxilary function for tree, for recursive
iteration, but it isn't so simple to have multiple generators
for multiple subtrees.

It also alows composing and delegating recursive iterators.
+/

private:
	/** Entry point for generator, it will just call method iter() */
	final void run() {
		iter();
		throw new GeneratorEndException(this, "abstract fiber generator");
	}

protected:
	/** Exceuted on entry point of generator, it should be implemented in derived class */
	abstract void iter();

public:
	/** Simple foreach implementation for this generator
	 *
	 * Note: if generator is infinite, it can loop infinitly.
	 *   Remeber to stop processing in some point, by break, return, or exception.
	 *
	 * See also: Foreach template class
	 */
	/*final*/ int opApply(int delegate(ref T) dg) {
		try {
/+
			while (true) {
				auto x = G.getNext();
				dg(x);
			}
+/
			// this is about 10% faster
			while (state != Fiber.State.TERM) {
				call();
				auto x = value;
				dg(x);
			}

		} catch (GeneratorEndException ge) {
			if (ge.who is this) {
				debug(exceptions) writefln("Generator G end exception: %s", ge.msg);
			} else {
				debug(exceptions) writefln("Generator ?? end exception: %s", ge.msg);
				throw ge;
			}
			return 0;
		} catch (GeneratorException ge) {
			debug(exceptions) writefln("Generator exception: %s", ge.msg);
			if (ge.who !is  this) {
				throw ge;
			}
			return 1;
		}
		return 0;
	}

}

/** Constant generator
 *
 * TODO: implement as raw Generator (without Fiber)
 */
final class Constant(T) : FiberGenerator!(T) {
private:
	T c;

public:
	/// Infinite generator which constantly returns value c.
	this (T c_) {
		c = c_;
	}

protected:
	override void iter() {
		while (true) {
			yield(c);
		}
	}
}

/** Simple iterator over array of type T[]
 *
 * TODO: this generator can be implemented without using FiberGenerator,
 *       Just implement nacassary Generator!(T) interface, which is very simple.
 *       Remember i (index of current element) as field in class.
 */
final class Array(T) : FiberGenerator!(T) {
private:
	T[] array;

public:
	///
	this (T[] array_) {
		array = array_;
		super();
	}

protected:
	override void iter() {
		foreach (x; array) {
			yield(x);
		}
	}

}

/** Simple generator generating number from interval [0, count)
 *
 * TODO: this generator can be implemented without using FiberGenerator,
 *       Just implement nacassary Generator!(T) interface, which is very simple.
 *       Remember t (curent value) as field in class.
 */
final class Range(T) : FiberGenerator!(T) {
private:
	T start, end, step;

public:
	/** count is upper bound of interval - it is the number of values yielded */
	this(int count) {
		start = 0;
		end = count;
		step = 1;
		super();
	}

	/** generated [start, start+step, start+2*step, ..., x]
	 *
	 * x is strictly smaller than end. (end is never included in sequence).
	 * Formally x is number larger-equal than start, x = start + k*step,
	 * with such k >= 0, that x < end, and x is largest such value.
	 *
	 * If start >= end, and step > 0, then sequence is empty.
	 * Similary if start <= end, and step < 0, then sequence is empty.
	 *
	 * If start > end, and step < 0, then sequence is generated
	 * in reverse order with step = -step.
	 */
	this(int start_, int end_, int step_ = 1) {
		start = start_;
		end = end_;
		step = step_;
		super();
	}

protected:
	override void iter() {
		for (T t = start; t < end; t += step) {
			yield(t);
		}
	}
}

/** Read all data from t and yield it again using t.
 *
 * Note: This should be called ONLY form the Fiber's iter() function.
 */
void reyield(T)(FiberGenerator!(T) t, Generator!(T) g) {
/+
	auto gf = cast(FiberGenerator!(T))g;
	if (gf !is null) {
		gf.iter(t); // directly call iter method without starting new fiber
	} else {
+/
		foreach (x; g) {
			t.yield(x);
		}
//	}
}

/** Repeat (infinitly) generator provided by delegate dg
 *
 * TODO: implement as raw Generator (without Fiber)
 */
final class Repeat(T) : FiberGenerator!(T) {
private:
	Generator!(T) delegate() dg;
public:
	///
	this(Generator!(T) delegate() dg_) {
		dg = dg_;
	}
protected:
	override void iter() {
		while (true) {
			auto g = dg();
			reyield(this, g);
		}
	}
}

/** yield every Nth value from G skiping rest
 *
 * TODO: implement as raw Generator (without Fiber)
 */
final class Every(T) : FiberGenerator!(T) {
private:
	Generator!(T) g;
	const uint N;
public:
	///
	this(Generator!(T) g_, uint N_) {
		assert(N_ > 0);
		g = g_;
		N = N_-1;
	}
protected:
	override void iter() {
		while (true) {
			for (int i = 0; i < N; i++) {
				g.getNext();
			}
			yield(g.getNext());
		}
	}
}




/** Concatenate generators returned by generator g.
 *
 * For simiplicity it can be also array of generator,
 * Array generator will be automatically created.
 *
 * It can be viewed as flattening generators,
 * but not recursive.
 *
 * Remember to make all generator be finite (or ending),
 * if this generator should end.
 *
 * TODO: implement as raw Generator (without Fiber)
 */
final class Concat(T) : FiberGenerator!(T) {
private:
	Generator!(Generator!(T)) gg;
public:
	///
	this(Generator!(Generator!(T)) gg_) {
		gg = gg_;
	}
	///
	this(Generator!(T)[] g_array) {
		this(new Array!(Generator!(T))(g_array));
	}
protected:
	override void iter() {
		while (true) {
			auto g = gg.getNext();
			reyield(cast(FiberGenerator!(T))this, g);
		}
	}
}

/** Interleave generators taking one value from each,
 * in round-robin fashion.
 *
 * TODO: documentate exactly policy on end of streams.
 * TODO: implement as raw Generator (without Fiber)
 */
final class Interleave(T) : FiberGenerator!(T) {
private:
	Generator!(T)[] g_array;
public:
	///
	this(Generator!(T)[] g_array) {
		g_array = g_array_;
	}
protected:
	override void iter() {
		while (true) {
			foreach (ref g; g_array) {
				//if (g !is null) {
					yield(g.getNext());
				//}
			}
		}
	}
}




/** Creates class usefull for iteration using foreach construct,
 * from generator G of type T.
 *
 * Note: if generator G is infinite, foreach will loop
 *  indefinitle. If needed remember to keep track of number of items
 *  processed, or derive other stop condition. Then use, break, or
 *  exception to leave foreach.
 *
 *
 * Note: This isn't very usefull, because Generator!(T) interface, already
 *       makes opApply mandatory, and also FiberGenerator!(T) implements
 *       it directly.
 * TODO: remove this class if possible.
 */
final class Foreach(T, alias G) {
	static assert(is(typeof(G) : Generator!(T)));

	///
	int opApply(int delegate(ref T) dg) {
		try {
			static if(is(G : FiberGenerator!(T))) {
				// this is about 10% faster
				while (G.state != Fiber.State.TERM) {
					G.call();
					auto x = G.value;
					dg(x);
				}
			} else {
				while (true) {
					auto x = G.getNext();
					dg(x);
				}
			}
		} catch (GeneratorEndException ge) {
			if (ge.who is G) {
				debug(exceptions) writefln("Generator G end exception: %s", ge.msg);
			} else {
				debug(exceptions) writefln("Generator ?? end exception: %s", ge.msg);
				throw ge;
			}
			return 0;
		} catch (GeneratorException ge) {
			debug(exceptions) writefln("Generator exception: %s", ge.msg);
			if (ge.who !is G) {
				throw ge;
			}
			return 1;
		}
		return 0;
	}
}

/** Creates class usefull for iteration using foreach construct,
 * from generator G of type T.
 * It additionally yields no more than limit values.
 *
 * Usefull if generator G is infinite.
 *
 * TODO: Make it implement interface Generator!(T)
 *       (or maybe separate class named Limit!(T,...,limit)
 *       so it one can create generator which is just
 *       truncated sequence of other generator.
 */
final class Foreach(T, alias G, alias limit) : FiberGenerator!(T) { // alias or uint
	static assert(is(typeof(G) : Generator!(T)));

	///
	override int opApply(int delegate(ref T) dg) {
		try {
			ulong i = 0;

			static if(is(typeof(G) : FiberGenerator!(T))) {
				// this is about 10% faster
				while (i++ < limit && G.state != Fiber.State.TERM) {
					G.call();
					auto x = G.value;
					dg(x);
				}
			} else {
				while (i++ < limit) {
					auto x = G.getNext();
					dg(x);
				}
			}
		} catch (GeneratorEndException ge) {
			if (ge.who is G) {
				debug(exceptions) writefln("Generator G end exception: %s", ge.msg);
			} else {
				debug(exceptions) writefln("Generator ?? end exception: %s", ge.msg);
				throw ge;
			}
			return 0;
		} catch (GeneratorException ge) {
			debug(exceptions) writefln("Generator exception: %s", ge.msg);
			if (ge.who !is G) {
				throw ge;
			}
			return 1;
		}
		return 0;
	}

protected:
	override void iter() {
		foreach (ref T x; this) {
			yield(x);
		}
	}
}


/** Simple function to iterate over two generators simulatniously.
 *
 * ----
 * auto a = new Range!(int)(3)
 * auto b = new Array!(float)([0.1f, 0.7, 0.4])
 * concurant_foreach!(int, float)(a, b, void (int x, float y) {
 *   writefln("x=%d y=%f", x, y);
 * });
 * ----
 *
*/
int concurant_foreach(A, B)(Generator!(A) G, Generator!(B) H, void delegate(A, B) dg) {
	try {
		while (true) {
			auto x = G.getNext();
			auto y = H.getNext();
			dg(x, y);
		}
	} catch (GeneratorEndException ge) {
		if (ge.who is G) {
			debug(exceptions) writefln("Generator G end exception: %s", ge.msg);
		} else if (ge.who is H) {
			debug(exceptions) writefln("Generator H end exception: %s", ge.msg);
		} else {
			debug(exceptions) writefln("Generator ?? end exception: %s", ge.msg);
			throw ge;
		}
		return 0;
	} catch (GeneratorException ge) {
		debug(exceptions) writefln("Generator general exception: %s", ge.msg);
		if (ge.who !is G && ge.who !is H) {
			throw ge;
		}
		return 1;
	}
	return 0;
}

/** Similar to concurant_foreach function, but you first create object
 * and then you can use foreach construct over it.
 *
 * Similar to zip/map.
 *
 *
 * ----
 * auto a = new Range!(int)(3)
 * auto b = new Array!(float)([0.1f, 0.7, 0.4])
 * auto ab = new ConcurantForeach!(int, float)(a, b);
 * foreach (x, y; ab) {
 *   writefln("x=%d y=%f", x, y);
 * }
 * ----
 *
 * Remark: Behaviour is undefined if iterators have different length.
 * TODO: If one of generators ends, check second.
 *
 * TODO: Make this class have interface Generator!(Tuple!(A,B)) allowing,
 *       for more generic code (and use more than two generators)
 * TODO: this generator can be implemented without using FiberGenerator,
 *       Just implement nacassary Generator!(C) interface, which is very simple.
 *
 */
final class ConcurantForeach(A, B) {
private:
	Generator!(A) G;
	Generator!(B) H;

public:
	///
	this(Generator!(A) G_, Generator!(B) H_) {
		G = G_;
		H = H_;
	}

	///
	int opApply(int delegate(ref A, ref B) dg) {
		try {
			while (true) {
				auto x = G.getNext();
				auto y = H.getNext();
				auto r = dg(x, y);
				if (r) {
					return r;
				}
			}
		} catch (GeneratorEndException ge) {
			if (ge.who is G) {
				debug(exceptions) writefln("Generator G end exception: %s", ge.msg);
			} else if (ge.who is H) {
				debug(exceptions) writefln("Generator H end exception: %s", ge.msg);
			} else {
				debug(exceptions) writefln("Generator ?? end exception: %s", ge.msg);
				throw ge;
			}
			return 0;
		} catch (GeneratorException ge) {
			debug(exceptions) writefln("Generator general exception: %s", ge.msg);
			if (ge.who !is G && ge.who !is H) {
				throw ge;
			}
			return 1;
		}
		//return 0;
		// this statment is not reachble: why? in try we have infinite while loop,
		//it can only be escaped by exception, so only by catch (which all rethrow or returns)
		// or in finally (which rethrows)
	}
}

/** Creates generator which concurently traverse two generators
 *
 * Concurently takes values from G and H of types A and B respectivelly,
 * and call function dg(A,B), and yields value of this function
 *
 * Note: both generator should generate the same number of values,
 * or be infinite.
 *
 * ----
 * auto a = new Range!(int)(4)
 * auto b = new Array!(float)([0.1f, 0.7, 0.4, 0.5])
 * auto ab = new ConcurantGenerator!(int, float, double)(a, b,
 *               delegate double(int x, float y) { return x*y; });
 * foreach (xy; ab) {
 *   writefln("%f", xy);  // prints 0.0, 0.7, 0.8, 1.5
 * }
 * ----
 *
 * Remark: it is good practice to use delegate which is pure,
 *         without any side effects.
 * Note: It is similar to Map generator, but takes two different
 *       (or the same, but it should not be used in this way)
 *       instand of one generator. It is equivalent to using
 *       first Zip and then Map on tuples.
 * TODO: this generator can be implemented without using FiberGenerator,
 *       Just implement nacassary Generator!(C) interface, which is very simple.
 */
final class ConcurantGenerator(A, B, C) : FiberGenerator!(C) {
private:
	Generator!(A) G;
	Generator!(B) H;
	C delegate(A, B) dg;

public:
	///
	this(Generator!(A) G_, Generator!(B) H_, C delegate(A, B) dg_) {
		G = G_;
		H = H_;
		dg = dg_;
	}

protected:
	override void iter() {
		try {
			while (true) {
				auto x = G.getNext();
				auto y = H.getNext();
				auto z = dg(x, y);
				yield(z);
			}
		} catch (GeneratorEndException ge) {
			if (ge.who is G) {
				debug(exceptions) writefln("Generator G end exception: %s", ge.msg);
			} else if (ge.who is H) {
				debug(exceptions) writefln("Generator H end exception: %s", ge.msg);
			} else {
				debug(exceptions) writefln("Generator ?? end exception: %s", ge.msg);
				throw ge;
			}
			//return 0;
			return;
		} catch (GeneratorException ge) {
			debug(exceptions) writefln("Generator general exception: %s", ge.msg);
			if (ge.who !is G && ge.who !is H) {
				throw ge;
			}
			//return 1;
			return;
		}
		//return 0;
		return;
	}
}

/** Traverse n generators of type A concurantly
 *
 */
final class MultiForeach(A, uint n) { // : Generator!(A[n]) {
private:
	Generator!(A)[n] G;

public:
	///
	this(Generator!(A)[n] G_) {
		G[] = G_[];
	}

	///
	int opApply(int delegate(ref A[n]) dg) {
		try {
			A[n] temp;
			while (true) {
				foreach (i; 0 .. n) {
					temp[i] = G[i].getNext();
				}
				auto r = dg(temp);
				if (r) {
					return r;
				}
			}
		} catch (GeneratorEndException ge) {
			foreach (i; 0 .. n) {
				if (ge.who is G[i]) {
					debug(exceptions) writefln("Generator G[%d] end exception: %s", i, ge.msg);
					return 0;
				}
			}

			debug(exceptions) writefln("Generator ?? end exception: %s", ge.msg);
			throw ge;
		} catch (GeneratorException ge) {
			debug(exceptions) writefln("Generator general exception: %s", ge.msg);
			foreach (i; 0 .. n) {
				if (ge.who is G[i]) {
					debug(exceptions) writefln("Generator general exception in G[%d]: %s", i, ge.msg);
					return 1;
				}
			}
			throw ge;
		}
		//return 0;
		// this statment is not reachble: why? in try we have infinite while loop,
		//it can only be escaped by exception, so only by catch (which all rethrow or returns)
		// or in finally (which rethrows)
	}
}


/** Take sum of all values in g.
 *
 * Note: If generator g produces infinite number of values,
 * it will loop forever.
 *
 * TODO: use direct calls to getNext(), (or just use foreach over g) so Foreach class will not be unacassarly be created
 * Note: it is possible to implement summer as foldl
 */
T summer(T)(Generator!(T) g) {
	static if (is(T == float) || is(T == double) || is(T == real)
		|| is(T == cfloat) || is(T == cdouble) || is(T == creal)
		|| is(T == ifloat) || is(T == idouble) || is(T == ireal)
		) {
		T s = cast(T)(0.0);
		/// TODO: Kahan update for floats
	} else {
		T s;
	}
	foreach (T x; new Foreach!(T, g)()) {
		s += x;
	}
	return s;
}

/** Summer for int values */
alias summer!(int) sumint;
/** Summer for float values */
alias summer!(float) sumfloat;


/** Takes generator H of type T as input, and re-yields only values
 * for which predicate f is true.
 *
 * Note: symbol f should point to delegate.
 * Note: delegate f should be pure, without any side effects
 *
 * TODO: this generator can be implemented without using FiberGenerator,
 *       Just implement nacassary Generator!(T) interface, which is very simple.
 *
 * TODO: allow f to be string, to directly inline it
 */
final class Filter(T, alias f) : FiberGenerator!(T) {
private:
	Generator!(T) G;

public:
	///
	this(Generator!(T) G_) {
		G = G_;
		super();
	}

protected:
	override void iter() {
		foreach (x; new Foreach!(T, G)()) {
			if (f(x)) {
				yield(x);
			}
		}
	}
}

/// ditto
final class Filter(T) : FiberGenerator!(T) {
private:
	Generator!(T) G;
	bool delegate(T) dg;

public:
	///
	this(Generator!(T) G_, bool delegate(T) dg_) {
		G = G_;
		dg = dg_;
		super();
	}

protected:
	override void iter() {
		foreach (x; new Foreach!(T, G)()) {
			if (dg(x)) {
				yield(x);
			}
		}
	}
}


/** Take generator G of type T2 and yields value f(v) of
 * type T for each element v in it
 *
 * Note: symbol f should point to delegate.
 * Note: delegate f should be pure, without any side effects.
 *
 * TODO: this generator can be implemented without using FiberGenerator,
 *       Just implement nacassary Generator!(T) interface, which is very simple.
 * TODO: allow f to be string constant literal, defining inline function
 */
final class Map(T, T2, alias f) : FiberGenerator!(T) {
private:
	Generator!(T2) G;
public:
	///
	this(Generator!(T2) G_) {
		G = G_;
		super();
	}

protected:
	override void iter() {
		foreach (x; new Foreach!(T, G)()) {
			yield(f(x));
		}
	}
}

/// ditto
final class Map(T, T2) : FiberGenerator!(T) {
private:
	Generator!(T2) G;
	T delegate(T2) dg;
public:
	///
	this(Generator!(T2) G_, T delegate(T2) dg_) {
		G = G_;
		dg = dg_;
		super();
	}

protected:
	override void iter() {
		foreach (x; new Foreach!(T, G)()) {
			yield(dg(x));
		}
	}
}

/** Traverses generator g of type T, calling on each item delegate dg
 * with value as first argument, and accumulator of type T2 as second,
 * initially starting with accumulator = init.
 *
 * Returns accumulator of last call from dg.
 *
 * Note: delegate dg should be pure.
 * Note: if possible dg should be associative function:
 * ---
 *   (a + b) + c ==  a + (b + c)
 *   dg(a, dg(b, c)) == dg(dg(a, b), c)
 * ---
 *   It will allow in principle to run foldl in parallel, and combine results easly.
 * Note: dg don't neet to be comutative, and in fact is is obvious because T and T2 can be of different types.
 *
 * TODO: use direct calls to getNext(), (or just use foreach over g) so Foreach class will not be unacassarly be created
 */
T2 foldl(T, T2)(Generator!(T) g, T2 init, T2 delegate (T, T2) dg) {
	T2 acc = init;
	foreach (T x; new Foreach!(T, g)()) {
		acc = dg(x, acc);
	}
	return acc;
}

/+
/** TODO: find  - iterate until predicate on value is true,
 * and return only this value and position
 */
void find() {
}
+/

/** foldl_gen - generator which esentially is fold+map in one pass.
 *
 * Note: delegate f should return struct FoldlGen!(...).V with
 *       fields emit_val and acc, as map (value to yielded)
 *       and foldl (accumulator to remember)
 * Note: g should be pure
 * TODO: it can be implemented without Fiber, just like Map or Filter
 * TODO: this generator can be implemented without using FiberGenerator,
 *       Just implement nacassary Generator!(T) interface, which is very simple.
 */
class FoldlGen(T, T2, AccT, alias f) : FiberGenerator!(T) {
	//delegate V(T, T2) f;
	struct V { T2 emit_val; AccT acc; };
private:
	Generator!(T2) G;
	AccT acc;
public:
	///
	this(Generator!(T2) G_, AccT init_acc) {
		acc = init_acc;
		G = G_;
	}
protected:
	override void iter() {
		while(true) {
			auto x = G.getNext();
			V v = f(x, acc);
			acc = v.acc;
			yield(v.emit_val);
		}
	}
}



/** This class is written because Fiber's are not correctly garbage collected
 *
 * This will leak:
 * ---
 *  foreach (i; 1 .... 10_000_000) {
 *    auto ar = new AR!(1)(rg, 10.0, 1.0, [0.8], 0.0);
 *    foreach (y; new Foreach!(float, ar, 200)()) {
 *      writefln("%f", y);
 *    }
 *  }
 * ---
 *
 * This will be properly garbage collected
 * ---
 *  foreach (i; 1 .... 10_000_000) {
 *    auto genwraped_ar = new GenWrap!(AR!(1), float)(new AR!(1)(rg, 10.0, 1.0, [0.8], 0.0));
 *    foreach (y; new Foreach!(float, genwraped_ar, 200)()) {
 *      writefln("%f", y);
 *    }
 *  }
 * ---
 *
 *
 *
 * Note: This class implements Generator!(T) interface, so
 *       most other classes and function which expects Generator!(T)
 *       will work with this wrapped generator.
 */
class GenWrap(T, F) : Generator!(T) {
	static assert (is(F : FiberGenerator!(T)));

	private F x;

	/** Creates wrapper around x_ of type F derived from FiberGenerator!(T)
	 *
	 * Remark: If possible x_ should not be a variable, but direct value from new operator:
	 *
	 * Do NOT:
	 * ---
	 *    auto ar = new AR!(1)(rg, 10.0, 1.0, [0.8], 0.0)
	 *    auto genwraped_ar = new GenWrap!(AR!(1), float)(ar);
	 * ---
	 *
	 * Do:
	 * ---
	 *    auto genwraped_ar = new GenWrap!(AR!(1), float)(new AR!(1)(rg, 10.0, 1.0, [0.8], 0.0));
	 * ---
	 */
	this(F x_) {
		x = x_;
	}

	/** Creates wrapper around dg()
	 *
	 * Note: Delegate is used to not polute caller stack space even in principle.
	 *
	 * ---
	 *    auto genwraped_ar = new GenWrap!(AR!(1), float)(
	 *         () { return new AR!(1)(rg, 10.0, 1.0, [0.8], 0.0); }
	 *       );
	 * ---
	 */
	this(F delegate() dg) {
		x = dg();
	}

	/** Destroys underling wrapped FiberGenerator.
	 *
	 * It will be called automatically by Garbage Collector when needed.
	 */
	~this() {
		delete x;
	}

	/** Forward interface function to embeded F derived from FiberGenerator!(T) */
	T get() {
		return x.get();
	}
	/// ditto
	T getNext() {
		return x.getNext();
	}
	/// ditto
	bool next() {
		return x.next();
	}
	/// ditto
	int opApply(int delegate(ref T) dg) {
		return x.opApply(dg);
	}

	/** Allow direct access to underlining FiberGenerator!(T)
	 *
	 * Attention: You need to be sure, that object returned by this
	 * function is not referenced/used after this wrapper object is destroyed,
	 * because it will be not valid.
	 *
	 * You have been warned.
	 */
	F o() {
		return x;
	}
}

/// Fill array x by values retrived from g.
void fill(T)(Generator!(T) g, T[] x) {
	foreach (ref xi; x) {
		xi = g.getNext();
	}
}



/** Lazy fiber generators are usefull if we want to implement,
 * other generator which will use values, but they are not generated,
 * usefull for example for pushing new values to the generator, and continuing
 * execution.
 * It is also usefull in complicated chains of generators,
 * normally only last generator value will be only one accessible.
 *
 * By Lazy fiber generator we can explicictly broke this chain into two
 * separate parts, and easly retrive intermidiate value,
 * or put it into two saparate fibers which accepts other fibers as input,
 * without any complicated buffering.
 * This also allows interupting input generator  (and in the effect also output genertor)
 * by inspecting values generated by output (ie. avg above the defined level).
 * We call such scenario, master/slave consumer. Slave is passive consumer,
 * it only consumes if master consumer explicitly consumed something.
 *
 * So we can for example calculate min/max of values that master consumed.
 * With minmax it's not big problem, we can add wrapping proxy,
 * which calculate this, and pass back notchanged value.
 *
 * For example we normally can't do this to inspect what values was passed in beetwen.
 * ---
 * auto rg = new RandomsGauss(seed, 0.0f, 1.0f);
 * auto g = new GARCH!(1,1)(rg, [0.9f], [1.0f, 0.1], 0.0);
 * auto r = new InvLir(g);
 * foreach (i; 0 .. 100) {
 *    writefln(r.getNext(), g.getNext(), rg.getNext());
 * }
 * ---
 *
 * This is because we will trigger multiple getNext in rg for example.

 * also hack like this
 * ---
 *    r.getNext();
 *    writefln(r.value, g.value, rg.value);
 * ---
 * will not always work (in generality we don't know / or should not know how many values
 * was consumed by intermidiate steps).
 *
 * We can do simple men-in-the-middle like this:
 *
 * ---
 * auto rg = new RandomsGauss(seed, 0.0f, 1.0f);
 * auto lazy_rg = new LazyFiberGenerator!(float)(rg, delegate void(float rg_x) { writefln("random: %f", rg_x); });
 * auto g = new GARCH!(1,1)(lazy_rg, [0.9f], [1.0f, 0.1], 0.0);
 * foreach (i; 0 .. 100) {
 *    writefln(g.getNext());
 * }
 * ---
 *
 * which is quite natural, and just adds some monitor in beetwen,
 * unfortunetly we can't use this scheme easly to use passed
 * value as a source to other generators.
 *
 * We can do more control using something like this:
 *
 * ---
 * auto rg = new RandomsGauss(seed, 0.0f, 1.0f);
 * auto lazy_rg = new LazyFiberGenerator!(float)(rg);
 * auto g = new GARCH!(1,1)(lazy_rg, [0.9f], [1.0f, 0.1], 0.0);
 * foreach (i; 0 .. 100) {
 *    lazy_rg.mitm = delegate void(float rg_x) { writefln("random: %f", rg_x); };
 *    writefln(g.getNext());
 * }
 * ---
 *
 * but suppose we want to feed exactly the same data into two consumers.
 *
 * ---
 * auto rg = new RandomsGauss(seed, 0.0f, 1.0f);
 *
 * ; // forward declaration
 *
 * auto lazy_rg = new LazyFiberGenerator!(float)(rg, );
 *
 * g = new GARCH!(1,1)(lazy_rg, [0.9f], [1.0f, 0.1], 0.0);
 * m = new MinMax();
 *
 * foreach (i; 0 .. 100) {
 *    lazy_rg.mitm = delegate void(float rg_x) { writefln("random: %f", rg_x); };
 *    writefln(g.getNext());
 * }
 * ---
 *
 *
 * Patterns like, Duplicator or data analysis classes from hist, like Hist, Moments, MinMax,
 * can be easly ported to this framework (normally they will loop infinitly).
 *
 *
 */
class GeneratorProxy(T) : Generator!(T) {
private:
	Generator!(T) g;
	void delegate(T) dg;
	bool have_dg;

public:
	/// monitoring delegate dg will be called on each next/getNext call (on the caller side)
	this(Generator!(T) g_, void delegate(T) dg_) {
		g = g_;
		dg = dg_;
		have_dg = true;
	}

	/// start without monitoring delegate
	this(Generator!(T) g_) {
		g = g_;
		have_dg = false;
	}

	/// change monitoring delegate
	void set_monitor(void delegate(T) dg_) {
		dg = dg_;
		have_dg = true;
	}

	override T getNext() {
		next();
		return get();
	}

	override T get() {
		return g.get();
	}

	override bool next() {
		if (g.next()) {
			if (have_dg) { dg(get()); }
			return true;
		} else {
			return false;
		}
	}

	mixin OpApplyMixin!(T) opApply;
}

/// Limits generator to at most first count elements.
class Limit(T) : Generator!(T) {
private:
	Generator!(T) g;
	uint count;
public:
	///
	this(Generator!(T) g_, uint count_) {
		g = g_;
		count = count_;
	}

	override T getNext() {
		if (count == 0) { throw new GeneratorEndException(this, "limit end"); }
		count--;
		try {
			return g.getNext();
		} catch (GeneratorEndException ge) {
			if (ge.who is g) {
				throw new GeneratorEndException(this, "limit subgen end");
			}
			throw ge;
		}
	}

	override T get() {
		return g.get();
	}

	override bool next() {
		if (count == 0) { return false; }
		count--;
		return g.next();
	}

	mixin OpApplyMixin!(T) opApply;
}

/+
void LazyFiberGenerator(T) : Generator!(T) {
	void putNext(T x) {
	}
	T getNext() {
	}
}
+/



/** Just like FiberGenerator, but reduces context switches
 * using buffering.
 *
 * Standard FiberGenerator have big overhead of yield method,
 * which suggest to write simple generators (in which overhead is
 * comparable or bigger than process of generating) by direct implementation
 * of the Generator interface. Unfortunetly programmer loses many advantages
 * of FiberGenerator interfaces: locality, simplicity of recursive generators.
 * And adds considerable boilerplate.
 *
 * This class allows for using FiberGenerator approach,
 * but amortizes overhead of context switches for the cost
 * of additional memory for buffer.
 *
 * There is additional method getNexts(int N) which tells to generate,
 * N values, and returns first, on subsequent N-1 calls,
 * it will returns buffered values.
 * Also getNext() will then return values from buffer.
 *
 * If there was no calls to getNexts(), or buffer is empty,
 * and one uses getNext(), last size of the buffer will be used.
 *
 * Filling of buffer is done on the generator Fiber context,
 * retriving data from buffer is done on the side of caller of getNext/getNext()
 *
 * Value N is provided for dynamically varing size of buffer,
 * it is also exposed to the Fiber via method int bufExpected(),
 * so it can be also used in calling nested generator.
 * It allows enforcing buffering policy to the whole
 * generators pipeline.
 *
 * Beyond yield(T) which works similary to original FiberGenerator,
 * but first tries to fill the buffer, and only then really yield,
 * few additional version are provided.
 *
 * Method yield(T[]) is equivalent to yielding all values from given array.
 * This class will do one of few things (and it is unspecified which one),
 *  1. will try to fill buffer with given values (and possibly switch if it will
 *     we filled),
 *  2. will maintain list of bufferes, and it will be traversed,
 *     on one of the side.
 *  3. it will save given array (by reference), switch immedietly,
 *     and read buffer (if non empty) and given array on the caller side.
 *
 * Method yield(Generator!(T)) is equivalent to yielding all values from
 * given generator. It is unspecified on which side of the
 * context values will be retrived (it can be on the Fiber side,
 * and will fill buffer, or it can be on the caller side in lazy manner,
 * moving context switches to the given generator, and reducing memory
 * by not using buffer).
 *
 * Method flush_yield() will (if buffer is nonempty) immedietly
 * switch context, and calling side will start to read buffer.
 *
 * Default buffer is 64 elements. Try to not exceed your L1 cache,
 * as it can decrese performance (we suggest to have buffer not bigger than 4-8 KB,
 * so about 10 such BufferedFiberGenerator will fit in 64KB L1 data cache).
 * For high performance numerical codes something like 1024 doubles,
 * or 2048 floats is sufficiently big value.
 * One definitvly should not make buffer bigger than L2 cache,
 * because as this class have very good locality and prefetching behaviour,
 * in case of L2 (which is quite fast) it isn't so true for RAM.


 *
 * To allow simple switching beetwen FiberGenerator and BufferedFiberGenerator,
 * original FiberGenerator exposes trivial versions of above described method,
 * 1. bufExpected will always return 1,
 * 2. flush_yield() will do nothing
 * 3. methods yield(T[]) and yield(Generator!(T)) will reyield values (on the Fiber side)
 * 4. yield will always yield immedietly like always.
 * 5. getNexts(N) is equivalent to getNext()
 *
 * Also bufExpected is avaible from Generator class, so one can use it
 * easly to implement own buffering or pass to nested Generators/FiberGenerators.
 *
 * It is important to know that this approach breaks ProxyGenerator class.
 * Normally ProxyGenerator will call some delegate on the caller side (Proxy isn't Fiber),
 * but if one will create pipe of such strucutre:
 * ---
 *  a=BufferedFiberGenerator -...>  b=Proxy(dg) -...> c=Generator
 * ---
 * calls to dg will be not synchronous with the a.getNext():
 *  a is buffering generator and will try to fill it's buffer,
 *  to do this it needs to read data from c. Because of buffering,
 *  it will preferebly read c in chunks (it is especially simple if c is also BufferedFiberGenerator,
 *  to which we can pass bufExpected value), so it will in beetween
 *  call dg many times. If dg is used to store intermidiate values
 *  in some variables which are accessible from outside,
 *  this will only remember last value of c in chunk.
 *
 * There is no easy and general solution to this problem.
 * Proxy (as all Generators) have access to bufExpected method,
 * and if nacassary can remember intermidiate values,
 * but it will still not make Proxy synchronous.
 * This is just contradictory to the idea behind BufferedFiberGenerator.
 *
 * One of possible (and quite elegant) solutions is to maintain
 * dynamic queue in the b.Proxy, and queue values in it.
 * It is then a matter of dequeueing values from queue,
 * somewhere else. Such approch is used in QueueProxy class.
 * If bufExpected is considerably constant this can be changed,
 * to circular buffer approach (eventually doubling
 * size of the buffer if nobody dequeued values or
 * a is still trying to fill own buffer).
 * Anyway in such scenario one needs to cerfully
 * choise size of buffers, because most intermidiate
 * Generator (Fibers, Proxy,Queue,and others) will use
 * buffers of such size, adding considerably memory overhead,
 * and possibly overflowing L1/L2 caches.
 *
 * Becuase of that it is always desirable to tune this values
 * in real programs, or rewrite most of FiberGenerators
 * as raw Generators.
 */

abstract class BufferedFiberGenerator(T) : AFiberGenerator, Generator!(T) {
protected:
	/** Starts Fiber with run method of this method. */
	this() {
		super(&run);
	}

public:
	void setBuf(int buf_exp_) {
		buf_exp = buf_exp_;
	}

private:
	///
	final void run() {
		bfg_ybuffer.length = buf_exp;
		iter();
		yield_flush();
		throw new GeneratorEndException(this, "abstract fiber generator");
	}

protected:
	/** Exceuted on entry point of generator, it should be implemented in derived class */
	abstract void iter();


private:
	T[] bfg_ybuffer; // buffer
	size_t bfg_ybuffer_next_i; // which portion of buffer was already readed
	size_t bfg_ybuffer_last_i; // last valid value in buffer

	//Generator!(T) bfg_yielded_gen;
	//T[] bfg_yielded_array;
	//size_t bfg_yielded_array_next_i;

	invariant() {
		if (bfg_ybuffer) {
			assert(bfg_ybuffer_next_i <= bfg_ybuffer.length);
			assert(bfg_ybuffer_next_i <= bfg_ybuffer_last_i);
		}
	}

	uint buf_exp = 4096;

protected:
	///
	final uint bufExpected() {
		return buf_exp;
	}

	//final void yield(T[] a) {
	//	bgf_yielded_array = a;
	//}

	//final void yield(Generator!(T) a) {
	//}

	/** yield value like in FiberGenerator.
	 *
	 * After bufExpected yields, buffer will be full,
	 * and it will be flushed.
	 */
	final void yield(T a) {
		debug(debug_buffering) writeln("yield");
		assert(bfg_ybuffer !is null);
		assert(bfg_ybuffer.length > 0);
		assert(bfg_ybuffer_last_i < bfg_ybuffer.length);
		bfg_ybuffer[bfg_ybuffer_last_i++] = a;
		if (bfg_ybuffer_last_i >= bfg_ybuffer.length) {
			yield_flush();
			assert(bfg_ybuffer_last_i == bfg_ybuffer_next_i); // all data was readed
			assert(bfg_ybuffer_last_i < bfg_ybuffer.length);
		}
	}

	/// force flushing
	final void yield_flush() {
		debug(debug_buffering) writeln("yield flush");
		assert(bfg_ybuffer_next_i <= bfg_ybuffer_last_i);
		if (bfg_ybuffer_next_i < bfg_ybuffer_last_i) { // only really flush if there buffer isn't empty
			super.yield();
		}
		assert(bfg_ybuffer_last_i == bfg_ybuffer_next_i);
		bfg_ybuffer_last_i = 0;
		bfg_ybuffer_next_i = 0;
	}

public:
	///
	final bool next() {
		debug(debug_buffering) writeln("next");
		if (bfg_ybuffer_next_i < bfg_ybuffer_last_i) {
			bfg_ybuffer_next_i++;
			if (bfg_ybuffer_next_i < bfg_ybuffer_last_i) {
				return true;
			} else {
				return more();
			}
		} else {
			return more();
		}
	}

	final bool more() {
		debug(debug_buffering) writeln("more");
		if (state == Fiber.State.TERM) {
			// empty buffer and fiber dead
			return false;
		} else {
			// go more and regenerate buffer
			assert(bfg_ybuffer_next_i == bfg_ybuffer_last_i);
			this.call();
			assert(bfg_ybuffer_next_i < bfg_ybuffer_last_i);
			return true;
		}
	}

	///
	final T get() {
		debug(debug_buffering) writeln("get");
		assert(bfg_ybuffer !is null);
		assert(bfg_ybuffer.length > 0);
		assert(bfg_ybuffer_next_i < bfg_ybuffer_last_i);
		assert(bfg_ybuffer_next_i < bfg_ybuffer.length);
		assert(bfg_ybuffer_last_i <= bfg_ybuffer.length);
		return bfg_ybuffer[bfg_ybuffer_next_i];
	}

	/** Same as next(), but returns yielded value,
	 * and throw GeneratorEndException if generator is not executing
	 */
	final T getNext() {
		debug(debug_buffering) writeln("getnext");
		if (next()) {
			return get();
		} else {
			throw new GeneratorEndException(this, "fibergenerator iteration ended");
		}
	}

	/// generic foreach
	mixin OpApplyMixin!(T) opApply;
}

/// testing performance 1
class Fib1 : FiberGenerator!(int) {
	override void iter() {
		int i;
		while (true) {
			yield(i++);
		}
	}
}

/// testing performance 2 (buffered)
class Fib1Buf : BufferedFiberGenerator!(int) {
	override void iter() {
		int i;
		while (true) {
			yield(i++);
		}
	}
}


/+

4000000 calls

1 = 0.700

2 = 1.090 s
8 = 0.690
32 = 0.595
128 = 0.565
4096 = 550


opt:
1 = 0.730

8 = 0.245
32 = 0.155
128 = 0.130
1024 = 0.125
4096 = 0.125



new with opt:
time ./corod_test 7 10000000 8

0 1.85
1 2.54
2 1.52
4 0.96
8 0.64
16 0.49
32 0.41
64 0.36
128 0.33

about 7 times faster.

+/

